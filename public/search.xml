<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BeanFactoryPostProcessor后置处理器分析</title>
    <url>/2017/08/29/BeanFactoryPostProcessor%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>BeanFactoryPostProcessor接口</p>
<p>bean工厂后置处理器,在bean创建之前，对bean工厂里的BeanDefinition对象进行加工处理，例如解释propertyValues属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;xmlPropertiesBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.XmlPropertiesBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;loginUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;loginUrl&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对${loginUrl}的解释替换工作由<strong>PropertySourcesPlaceholderConfigurer</strong>类完成。下面进入debug模式，验证解析过程。</p>
<p>首先在类<strong>PlaceholderConfigurerSupport</strong>的<strong>doProcessProperties</strong>方法的visitor.visitBeanDefinition(bd);所在行打上断点，并设置断点的条件**”xmlPropertiesBean”.equals(curName)**，如下图</p>
<span id="more"></span>

<p><img src="/2017/08/29/BeanFactoryPostProcessor%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E5%88%86%E6%9E%90/5.jpg" alt="5"></p>
<p>在断点处进行Evaluate执行代码，查看xmlPropertiesBean的loginUrl属性值，可以发现，该值还未替换。此时还没执行完PlaceholderConfigurerSupport后置处理器，接着F8单步执行完visitor.visitBeanDefinition(bd);该行代码，再观察xmlPropertiesBean的loginUrl属性值为<a href="http://www.baidu.com如下图/">www.baidu.com如下图</a></p>
<p><img src="/2017/08/29/BeanFactoryPostProcessor%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E5%88%86%E6%9E%90/6.jpg" alt="6"></p>
<p><strong>visitor.visitBeanDefinition访问者模式</strong></p>
<p>注意注解@Value(“${loginUrl}”)并不是由BeanFactoryPostProcessor解析的,下面的Value注解源码，可以看出@Value是AutowiredAnnotationBeanPostProcessor解释的。也就是由BeanPostProcessor处理的，和Autowired一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation used at the field or method/constructor parameter level</span></span><br><span class="line"><span class="comment"> * that indicates a default value expression for the annotated element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Typically used for expression-driven or property-driven dependency injection.</span></span><br><span class="line"><span class="comment"> * Also supported for dynamic resolution of handler method arguments &amp;mdash; for</span></span><br><span class="line"><span class="comment"> * example, in Spring MVC.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A common use case is to inject values using</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;#&#123;systemProperties.myProp&#125;&lt;/code&gt; style SpEL (Spring Expression Language)</span></span><br><span class="line"><span class="comment"> * expressions. Alternatively, values may be injected using</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;$&#123;my.app.myProp&#125;&lt;/code&gt; style property placeholders.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that actual processing of the &#123;<span class="doctag">@code</span> <span class="doctag">@Value</span>&#125; annotation is performed</span></span><br><span class="line"><span class="comment"> * by a &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor</span></span><br><span class="line"><span class="comment"> * BeanPostProcessor&#125; which in turn means that you &lt;em&gt;cannot&lt;/em&gt; use</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Value</span>&#125; within</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor</span></span><br><span class="line"><span class="comment"> * BeanPostProcessor&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> * types. Please consult the javadoc for the &#123;<span class="doctag">@link</span> AutowiredAnnotationBeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> * class (which, by default, checks for the presence of this annotation).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Autowired</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanExpressionResolver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.AutowireCandidateResolver#getSuggestedValue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Value &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The actual value expression such as &lt;code&gt;#&#123;systemProperties.myProp&#125;&lt;/code&gt;</span></span><br><span class="line"><span class="comment">	 * or property placeholder such as &lt;code&gt;$&#123;my.app.myProp&#125;&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>FactoryBean一探究竟.md</title>
    <url>/2023/06/29/FactoryBean%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F-md/</url>
    <content><![CDATA[<h2 id="Factorybean是什么？"><a href="#Factorybean是什么？" class="headerlink" title="Factorybean是什么？"></a>Factorybean是什么？</h2><p>factorybean是spring的一个接口类，是spring的一个扩展点之一。先来看一下具体的用法吧，不多说，上代码。源码</p>
<p>创建一个普通的类UserService，注意这个类没加任何注解。<a href="https://github.com/caiyl/cai.git">代码链接</a></p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chase.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chase</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/24 4:21 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       log.info(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个依赖了UserService的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chase.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chase</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/3/3 3:03 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个实现了FactoryBean接口的类，并重写**T getObject() throws Exception;<strong>和</strong>Class&lt;?&gt; getObjectType();**两个方法,注意该类加了注解@Service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chase.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chase</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/24 4:21 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserService&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;创建UserService对象&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserService.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动spring</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.chase.service.LoginService;</span><br><span class="line"><span class="keyword">import</span> com.chase.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.chase.service.UserServiceFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chase</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/2/24 4:20 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> SpringApplication.run(BootApp.class, args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userServiceFactoryBean&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;bean userServiceFactoryBean instanceof UserServiceFactoryBean:&quot;</span>+(bean <span class="keyword">instanceof</span> UserServiceFactoryBean));</span><br><span class="line">        System.out.println(<span class="string">&quot;bean userServiceFactoryBean instanceof UserService:&quot;</span>+(bean <span class="keyword">instanceof</span> UserService));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean1</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;&amp;userServiceFactoryBean&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&amp;userServiceFactoryBean instanceof UserServiceFactoryBean:&quot;</span>+(bean1 <span class="keyword">instanceof</span> UserServiceFactoryBean));</span><br><span class="line">        System.out.println(<span class="string">&quot;&amp;userServiceFactoryBean instanceof UserService:&quot;</span>+(bean1 <span class="keyword">instanceof</span> UserService));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LoginService <span class="title function_">getLoginService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginService</span>(userService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2023/06/29/FactoryBean%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F-md/1677828665083.jpg" alt="image-20230303152959177" style="zoom:50%;">

<p><strong>通过UserServiceFactoryBean创建了UserService对象的bean</strong>。</p>
<p><strong>什么时候调用FactoryBean的getObject创建对象？</strong></p>
<p>从控制台打印的结果可以看出，在spring容器启动完成前，会调用getObject方法，创建对象。一定是这样吗。下面我们注释一下以下代码，再跑一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public LoginService getLoginService(UserService userService) &#123;</span></span><br><span class="line"><span class="comment">//        return new LoginService(userService);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure>

<img src="/2023/06/29/FactoryBean%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F-md/1677834219275.jpg" alt="image-20230303152959177" style="zoom:50%;">

<p>为什么是spring容器启动完了才创建对象呢？在getObject方法入口处打个断点，看下堆栈信息如下</p>
<p><img src="/2023/06/29/FactoryBean%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F-md/1.jpg" alt="image-20230303172002986"></p>
<p>由此可见spring容器启动不会创建对象，当你需要用到factorybean里的对象是，才会进行初始化对象。再放开上面的代码注释，打个断点执行观察如下图</p>
<p><img src="/2023/06/29/FactoryBean%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F-md/2.jpg" alt="image-20230303173015635"></p>
<p><strong>上图可以看出在spring容器启动初始化阶段，由于创建LoginService类的bean需要userService，所以spring会去容器内部通过getBean获取UserService对象，发现不存在UserService对象时，找到能创建UserService对象的FactoryBean对象创建。</strong> 总结一下<strong>需要才创建</strong></p>
<p><strong>直接在UserService类加@Service注解不是更香吗，为什么要有这个骚操作创建对象</strong></p>
<p>假如要创建的对象很复杂，假如bean对象没有实现类呢，有没有那些地方用到了这个Factorybean值得学习的呢？当然有，要不然不就白白浪费了。其中大名鼎鼎的mybaits，还有spring cloud家族的OpenFeign都用到了。</p>
<p><img src="/2023/06/29/FactoryBean%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F-md/3.png" alt="image-20230303173015635"></p>
<p><img src="/2023/06/29/FactoryBean%E4%B8%80%E6%8E%A2%E7%A9%B6%E7%AB%9F-md/4.png" alt="image-20230303173015635"></p>
<p>这两个factoryBean都是利用动态代理生产代理类，交给spring容器管理。</p>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Taro学习</title>
    <url>/2023/07/26/Taro%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>终端命令安装：npm i -g @tarojs&#x2F;cli ，注意当前的node版本。v18.17.0</p>
<p>初始化项目 taro init</p>
<p>安装路由 npm install vue-router –save</p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql知识</title>
    <url>/2020/01/03/mysql%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="批量插入测试数据"><a href="#批量插入测试数据" class="headerlink" title="批量插入测试数据"></a>批量插入测试数据</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span></span><br><span class="line">    IF <span class="keyword">EXISTS</span> test_insert;</span><br><span class="line"></span><br><span class="line">DELIMITER ;;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_insert()</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> number <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">    WHILE (number <span class="operator">&lt;=</span> <span class="number">10000</span>) DO</span><br><span class="line"></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> testabc(a,b,c) <span class="keyword">values</span>(concat(<span class="string">&#x27;a&#x27;</span>,number),concat(<span class="string">&#x27;b&#x27;</span>,number),concat(<span class="string">&#x27;c&#x27;</span>,number));</span><br><span class="line">        <span class="keyword">SET</span> number <span class="operator">=</span> number <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">END</span>;;</span><br><span class="line"><span class="keyword">CALL</span> test_insert();</span><br></pre></td></tr></table></figure>

<h2 id="mysql日志"><a href="#mysql日志" class="headerlink" title="mysql日志"></a>mysql日志</h2><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>binlog是在<strong>server层的</strong>两个主要的用途</p>
<ol>
<li>主从复制</li>
<li>数据恢复</li>
</ol>
<p>binlog的格式也有3种</p>
<ol>
<li>statement：基于sql，数据有可能丢失，像now()函数</li>
<li>row:文件大，数据不丢失</li>
<li>Mixed</li>
</ol>
<p>Undolog</p>
<h2 id="icp索引下推"><a href="#icp索引下推" class="headerlink" title="icp索引下推"></a>icp索引下推</h2><p>加上有联合索引a、b、c字段，where a &#x3D;</p>
<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
  </entry>
  <entry>
    <title>循环依赖</title>
    <url>/2017/03/29/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<p>关于循环依赖先说几个点总结</p>
<ol>
<li>依赖三级缓存以及<strong>提前暴露引用</strong></li>
<li>循环依赖只能是单例的，如果是多例则会报错，多例循环依赖本身就是错误的，无法确定依赖那一个实例</li>
<li>构造器注入的循环依赖无法处理，会报错</li>
</ol>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot的自动装配</title>
    <url>/2023/07/03/springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<p><strong>Import</strong></p>
<p>Import可以导入一个普通的bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello PersonService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>Import可以导入ImportSelector</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;WeatherService.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Predicate&lt;String&gt; <span class="title function_">getExclusionFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ImportSelector.<span class="built_in">super</span>.getExclusionFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Import可以导入Configuration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.third.configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.third.service.LoginService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chase</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/3/6 4:56 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LoginService <span class="title function_">getLoginService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ImportSelector</p>
<p>ImportSelector可以导入多个bean</p>
<p>Configuration</p>
<p>Configuration是bean的配置文件</p>
<p><strong>每个Enablexxx背后都是Import在作怪。spring boot start的几个关键点，注解EnableAutoConfiguration</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@EnableRabbit</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableApolloConfig</span></span><br><span class="line"><span class="meta">@EnableRedissonLock</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(CachingConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCaching</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import(RabbitListenerConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRabbit</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import(SchedulingConfiguration.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import(&#123;ApolloConfigRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableApolloConfig</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import(&#123;RedissonDistributedLockAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRedissonLock</span><br></pre></td></tr></table></figure>

<p>由此可见，spring的Enablexxx背后都是Import。</p>
<p><strong>springboot的自动装配</strong></p>
<p>听起来很高端，实际上也是Enablexxx与Import在起作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication </span><br></pre></td></tr></table></figure>

<p>@SpringBootApplication注解是一个组合注解，有EnableAutoConfiguration何SpringBootConfiguration注解。</p>
<p>EnableAutoConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration</span><br></pre></td></tr></table></figure>

<p><strong>自动装配也不过是Enablexxx+Import</strong></p>
<p>AutoConfigurationImportSelector的部分代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">		if (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			return NO_IMPORTS;</span><br><span class="line">		&#125;</span><br><span class="line">		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">		return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">		if (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			return EMPTY_ENTRY;</span><br><span class="line">		&#125;</span><br><span class="line">		AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">		List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">		configurations = removeDuplicates(configurations);</span><br><span class="line">		Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">		checkExcludedClasses(configurations, exclusions);</span><br><span class="line">		configurations.removeAll(exclusions);</span><br><span class="line">		configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">		fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">		return new AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">		List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">				getBeanClassLoader());</span><br><span class="line">		Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span><br><span class="line">				+ &quot;are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">		return configurations;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AutoConfigurationImportSelector里的这三段代码用SpringFactoriesLoader类，加载了配置在类路径里的META-INF&#x2F;spring.factories类。</strong></p>
<p>META-INF&#x2F;spring.factories里就是官方的starter的Configuration配置类。了解了自动装配和Enablexxx，再来手动写一个</p>
<p>starter就信手沾来了。</p>
<ol>
<li>pom依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>写好配置类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HelloService <span class="title function_">getHelloService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="3">
<li>在META-INF&#x2F;spring.factories 加上</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.hello.configuration.HelloConfiguration</span><br></pre></td></tr></table></figure>

<p>3个步骤即可完成一个starter。另外如果不想写META-INF&#x2F;spring.factories文件，则写一个Enable注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(HelloConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHello &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在spring启动入口加上该注解即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHello</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootApp</span> </span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/caiyl/cai.git">代码链接</a></p>
]]></content>
  </entry>
  <entry>
    <title>池化技术导致cpu占用飙高问题分析</title>
    <url>/2023/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>某天其他部门的同事说，我负责的某个服务cpu占用很高，影响到他们的应用。我在想服务不是部署在容器里吗，不是资源隔离的吗，找了运维同事说，cpu确实没用限制。好吧，只能去分析原因了，否则影响到公司其他赚钱的业务系统就麻烦，处于责任心，和对技术的追求，决定还是处理一下。</p>
<p>思路，根据经验，老夫信心满满，内存问题，泄露，溢出，首先是dump出来，Memory Analyzer Tool工具分析。cpu问题，看线程，死循环，100%cpu？大题思路是没有变的，开始表演。</p>
<p>第一步，当然是找运维大佬，jstack pid 导出线程栈信息。然后top -H -p <pid> 查看线程那些线程占用高的。线程栈信息文件到手，top -H -p <pid>信息截图如下</pid></pid></p>
<img src="/2023/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E7%BA%BF%E7%A8%8B%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5.png" class title="线程占用情况">

<p>看到这个图，心中万马奔腾，怎么和自己想的不一样，不是有线程名称吗，也没有cpu占用特别高的线程啊，怎么办呢。</p>
<p>再仔细观察图，发现总共有561个线程，只有8个是running,553个是sleep状态。这里就十分奇怪了。到导出的线程栈文件看看那些线程是sleeping吧，没发现太多的线程sleeping，但是发现了很多是TIMED_WAITING状态，如下图</p>
<img src="/2023/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E9%98%BB%E5%A1%9E.jpg" class title="线程占用情况">

<p>仔细看发现是httpclient导致线程阻塞，突然想到项目中有大量的数据同步请求，是使用httpclient连接池实现的。问题就处在连接池身上。去看看连接池的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">defaultMaxConnection</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">PoolingHttpClientConnectionManager</span> <span class="variable">cm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoolingHttpClientConnectionManager</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	cm.setMaxTotal(<span class="number">100</span>);</span><br><span class="line">	cm.setDefaultMaxPerRoute(defaultMaxConnection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CloseableHttpClient <span class="title function_">getHttpClient</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> HttpClients.custom().setConnectionManager(cm).build();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最大100个并发，单个通道最大是50。。。。。。仔细想想业务中，有好几百个线程在不断地进行上游数据同步。线程获取不到httpclient链接，各个线程都在竞争获取链接，导致线程阻塞。根据实际情况修改成300个。</p>
<h1 id="模拟验证"><a href="#模拟验证" class="headerlink" title="模拟验证"></a>模拟验证</h1><p>首先需要模拟一个上游http服务，这里使用interfake模拟。</p>
<p>安装 npm install interfake -g</p>
<p>创建文件，内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;request&quot;: &#123;</span><br><span class="line">            &quot;url&quot;: &quot;/hello&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;get&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;response&quot;: &#123;</span><br><span class="line">            &quot;code&quot;: 200,</span><br><span class="line">            &quot;delay&quot;:200,</span><br><span class="line">            &quot;body&quot;: &#123;</span><br><span class="line">                &quot;say&quot;: &quot;hello world!&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;request&quot;: &#123;</span><br><span class="line">            &quot;url&quot;: &quot;/hello2&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;post&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;response&quot;: &#123;</span><br><span class="line">            &quot;code&quot;: 200,</span><br><span class="line">            &quot;delay&quot;: 100,</span><br><span class="line">            &quot;body&quot;: &#123;</span><br><span class="line">                &quot;theTime&quot;: &quot;Adventure Time!&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后启动 ：interfake -p 3001 –file .&#x2F;adventuretime.json</p>
<p>get访问 <a href="http://localhost:3001/hello%EF%BC%8C">http://localhost:3001/hello，</a> 模拟延时200</p>
<p>返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;say&quot;: &quot;hello world!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.apache.http.HttpStatus;</span><br><span class="line">import org.apache.http.client.config.RequestConfig;</span><br><span class="line">import org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line">import org.apache.http.client.methods.HttpGet;</span><br><span class="line">import org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line">import org.apache.http.impl.client.HttpClients;</span><br><span class="line">import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;</span><br><span class="line">import org.apache.http.util.EntityUtils;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class HttpClientUtils &#123;</span><br><span class="line"></span><br><span class="line">	private static Logger logger = LoggerFactory.getLogger(HttpClientUtils.class);</span><br><span class="line">	private static int defaultConnectionTimeout = 60000;</span><br><span class="line">	private static int defaultSoTimeout = 60000;</span><br><span class="line">	private static int defaultMaxConnection = 50;</span><br><span class="line">	private static PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		cm.setMaxTotal(100);</span><br><span class="line">		cm.setDefaultMaxPerRoute(defaultMaxConnection);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static CloseableHttpClient getHttpClient() &#123;</span><br><span class="line"></span><br><span class="line">		return HttpClients.custom().setConnectionManager(cm).build();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static String doGet(String url, Map&lt;String, String&gt; headers) &#123;</span><br><span class="line"></span><br><span class="line">		long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		HttpGet httppost = null;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line"></span><br><span class="line">			CloseableHttpClient httpclient = getHttpClient();</span><br><span class="line"></span><br><span class="line">			httppost = new HttpGet(url);</span><br><span class="line">			httppost.setConfig(RequestConfig.custom().setConnectionRequestTimeout(defaultConnectionTimeout)</span><br><span class="line">					.setConnectTimeout(defaultConnectionTimeout).setSocketTimeout(defaultSoTimeout).build());</span><br><span class="line"></span><br><span class="line">			if (headers != null &amp;&amp; headers.size() &gt; 0) &#123;</span><br><span class="line">				for (Map.Entry&lt;String, String&gt; entry : headers.entrySet()) &#123;</span><br><span class="line">					httppost.addHeader(entry.getKey(), entry.getValue());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			CloseableHttpResponse response = httpclient.execute(httppost);</span><br><span class="line"></span><br><span class="line">			int statusCode = response.getStatusLine().getStatusCode();</span><br><span class="line"></span><br><span class="line">			if (statusCode == HttpStatus.SC_OK) &#123;</span><br><span class="line">				return EntityUtils.toString(response.getEntity(), &quot;GBK&quot;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				logger.warn(&quot;doPost failed: &quot; + EntityUtils.toString(response.getEntity()));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			logger.error(&quot;url:&#123;&#125;,&quot;,url,e);</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			if (httppost != null) &#123;</span><br><span class="line">				httppost.releaseConnection();</span><br><span class="line">			&#125;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;execute:&#123;&#125;,used time:&#123;&#125;ms &quot; ,url,(System.currentTimeMillis() - startTime));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		for (int i = 0; i &lt; 300; i++) &#123;</span><br><span class="line">			Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					while (true)&#123;</span><br><span class="line">						String s = HttpClientUtils.doGet(&quot;http://localhost:3001/hello&quot;, new HashMap&lt;&gt;());</span><br><span class="line">						System.out.println(s+new Date());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			thread.setName(&quot;requestThread&quot;+i);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程统计</p>
<img src="/2023/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E7%BA%BF%E7%A8%8B%E7%BB%9F%E8%AE%A1.jpg" class title="线程统计">

<p>修改连接池配置 <em>defaultMaxConnection</em> 为 200 和 <em>cm</em>.setMaxTotal(200);</p>
<p>再重新测试观察如下图</p>
<img src="/2023/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E7%BA%BF%E7%A8%8B%E7%BB%9F%E8%AE%A12.jpg" class title="线程统计2">

<p>由此可以得出结论，合理配置httpclient连接数很重要。</p>
<p>最后分析一下，在本次排查问题中学到的一些知识，由于本次的线程都是有spring rabbitmq的消费监听创建的，其实这些消费线程是使用线程池处理的，这些线程池已经做了自动缩容，扩容处理，一般不建议另外新旧线程消费处理。具体代码可以去看SimpleMessageListenerContainer类的considerStoppingAConsumer方法和adjustConsumers方法。</p>
<h1 id="另外分析一个线程在线分析网站"><a href="#另外分析一个线程在线分析网站" class="headerlink" title="另外分析一个线程在线分析网站"></a>另外分析一个线程在线分析网站</h1><p> <a href="https://fastthread.io/">java线程分析网站</a></p>
<img src="/2023/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%901.jpg" class title="线程分析1">

<img src="/2023/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/08/31/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%902.jpg" class title="线程分析2">
]]></content>
  </entry>
  <entry>
    <title>遍历redis删除生产key</title>
    <url>/2023/07/03/%E9%81%8D%E5%8E%86redis%E5%88%A0%E9%99%A4%E7%94%9F%E4%BA%A7key/</url>
    <content><![CDATA[<p>某天运维说，你的系统redis存在大量的key不设置过期时间，而且key是乱码的（其实是jdk序列化的key）。</p>
<p>我让运维备份出来，连上去，使用scan 0 match * count 10000，查看发现大量的key是:b’\xac\xed\x00\x05t\x00\x1a’开头的，以下是删除脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis </span></span><br><span class="line">redis_host = <span class="string">&#x27;xxx.xxx.xxxx&#x27;</span></span><br><span class="line">redis_port = <span class="number">6379</span></span><br><span class="line">redis_db = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别扫描这三种模式的key删除</span></span><br><span class="line">key_pattern = <span class="string">&quot;hello*&quot;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = redis.Redis(host=redis_host, port=redis_port, db=redis_db)</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">cursor = <span class="number">0</span></span><br><span class="line">ct = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    cursor, keys = r.scan(cursor=cursor, <span class="keyword">match</span>=key_pattern, count=batch_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    	r.delete(key)</span><br><span class="line">    	ct = ct+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cursor == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(ct)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;finsh&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
